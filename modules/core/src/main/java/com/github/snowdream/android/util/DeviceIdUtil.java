package com.github.snowdream.android.util;

import android.content.Context;
import android.support.annotation.NonNull;
import com.github.snowdream.android.content.SharedPreferences;
import android.os.Build;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.text.TextUtils;

import java.io.*;
import java.util.UUID;

/**
 * Methods for get the unique android device id.
 * Created by hui.yang on 2015/11/23.
 *
 * see: http://syawlaus.com/remindme-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81%EF%BC%9F/
 */
public class DeviceIdUtil {
    //The unique android device id.
    private static String mDeviceID = null;

    private DeviceIdUtil() {
        throw new AssertionError("No constructor allowed here!");
    }


    /**
     * Need Permission: android.permission.READ_PHONE_STATE
     *
     * @param context
     * @return
     */
    public static String getUUID(@NonNull  Context context){
        if (!TextUtils.isEmpty(mDeviceID)){
            return mDeviceID;
        }

        DeviceUuidFactory factory = new DeviceUuidFactory(context);
        mDeviceID = factory.getDeviceUuid().toString() ;

        return mDeviceID;
    }

    private static class DeviceUuidFactory {

        protected static final String PREFS_FILE = "device_id.xml";
        protected static final String PREFS_DEVICE_ID = "device_id";
        protected volatile static UUID uuid;

        public DeviceUuidFactory(Context context) {
            if (uuid == null) {
                synchronized (DeviceUuidFactory.class) {
                    if (uuid == null) {
                        final SharedPreferences prefs =   new SharedPreferences(context,PREFS_FILE, 0);

                        final String id = prefs.getString(PREFS_DEVICE_ID, null);
                        if (id != null) {
                            // Use the ids previously computed and stored in the
                            // prefs file
                            uuid = UUID.fromString(id);
                        } else {
                            final String androidId = Settings.Secure.getString(
                                    context.getContentResolver(), Settings.Secure.ANDROID_ID);
                            // Use the Android ID unless it's broken, in which case
                            // fallback on deviceId,
                            // unless it's not available, then fallback on a random
                            // number which we store to a prefs file
                            try {
                                if (!"9774d56d682e549c".equals(androidId)) {
                                    uuid = UUID.nameUUIDFromBytes(androidId
                                            .getBytes("utf8"));
                                } else {
                                    final String deviceId = (
                                            (TelephonyManager) context
                                                    .getSystemService(Context.TELEPHONY_SERVICE))
                                            .getDeviceId();
                                    uuid = deviceId != null ? UUID
                                            .nameUUIDFromBytes(deviceId
                                                    .getBytes("utf8")) : UUID
                                            .randomUUID();
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw new RuntimeException(e);
                            }
                            // Write the value out to the prefs file
                            prefs.putString(PREFS_DEVICE_ID, uuid.toString()).commit();
                        }
                    }
                }
            }
        }

        /**
         * Returns a unique UUID for the current android device. As with all UUIDs,
         * this unique ID is "very highly likely" to be unique across all Android
         * devices. Much more so than ANDROID_ID is.
         *
         * The UUID is generated by using ANDROID_ID as the base key if appropriate,
         * falling back on TelephonyManager.getDeviceID() if ANDROID_ID is known to
         * be incorrect, and finally falling back on a random UUID that's persisted
         * to SharedPreferences if getDeviceID() does not return a usable value.
         *
         * In some rare circumstances, this ID may change. In particular, if the
         * device is factory reset a new device ID may be generated. In addition, if
         * a user upgrades their phone from certain buggy implementations of Android
         * 2.2 to a newer, non-buggy version of Android, the device ID may change.
         * Or, if a user uninstalls your app on a device that has neither a proper
         * Android ID nor a Device ID, this ID may change on reinstallation.
         *
         * Note that if the code falls back on using TelephonyManager.getDeviceId(),
         * the resulting ID will NOT change after a factory reset. Something to be
         * aware of.
         *
         * Works around a bug in Android 2.2 for many devices when using ANDROID_ID
         * directly.
         *
         * see http://code.google.com/p/android/issues/detail?id=10603
         *
         * @return a UUID that may be used to uniquely identify your device for most
         *         purposes.
         */
        public UUID getDeviceUuid() {
            return uuid;
        }
    }

    public static String getUUID1(@NonNull Context context){
        if (!TextUtils.isEmpty(mDeviceID)){
            return mDeviceID;
        }

        mDeviceID = Installation.id(context);

        return  mDeviceID;
    }

    private static class Installation {
        private static String sID = null;
        private static final String INSTALLATION = "INSTALLATION";

        public synchronized static String id(Context context) {
            if (sID == null) {
                File installation = new File(context.getFilesDir(), INSTALLATION);
                try {
                    if (!installation.exists())
                        writeInstallationFile(installation);
                    sID = readInstallationFile(installation);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return sID;
        }

        private static String readInstallationFile(File installation) throws IOException {
            RandomAccessFile f = new RandomAccessFile(installation, "r");
            byte[] bytes = new byte[(int) f.length()];
            f.readFully(bytes);
            f.close();
            return new String(bytes);
        }

        private static void writeInstallationFile(File installation) throws IOException {
            FileOutputStream out = new FileOutputStream(installation);
            String id = UUID.randomUUID().toString();
            out.write(id.getBytes());
            out.close();
        }
    }

    /**
     * Need Permission: android.permission.READ_PHONE_STATE
     *
     * @param context
     * @return
     */
    public static String getUUID2(@NonNull Context context){
        if (!TextUtils.isEmpty(mDeviceID)){
            return mDeviceID;
        }

        TelephonyManager tm = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
        final String DeviceId, SerialNum, androidId;
        DeviceId = tm.getDeviceId();
        SerialNum = tm.getSimSerialNumber();
        androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

        UUID deviceUuid = new UUID(androidId.hashCode(), ((long)DeviceId.hashCode() << 32) | SerialNum.hashCode());
        mDeviceID = deviceUuid.toString();

        return  mDeviceID;
    }

    // Here is the code that Reto Meier used in the google I/O presentation this year to get a unique id for the user:
    private static final String PREF_UNIQUE_ID = "PREF_UNIQUE_ID";
    public synchronized static String getUUID3(@NonNull Context context) {
        if (mDeviceID == null) {
            SharedPreferences sharedPrefs = new SharedPreferences(context,PREF_UNIQUE_ID,Context.MODE_PRIVATE);
            mDeviceID = sharedPrefs.getString(PREF_UNIQUE_ID, null);
            if (mDeviceID == null) {
                mDeviceID = UUID.randomUUID().toString();
                sharedPrefs.putString(PREF_UNIQUE_ID, mDeviceID);
                sharedPrefs.commit();
            }
        }

        return mDeviceID;
    }

    public synchronized static String getUUID4(@NonNull Context context) {
        if (!TextUtils.isEmpty(mDeviceID)){
            return mDeviceID;
        }

        mDeviceID  = "35"  //we make this look like a valid IMEI
                + Build.BOARD.length() % 10
                + Build.BRAND.length() % 10
                + Build.CPU_ABI.length() % 10
                + Build.DEVICE.length() % 10
                + Build.DISPLAY.length() % 10
                + Build.HOST.length() % 10
                + Build.ID.length() % 10
                + Build.MANUFACTURER.length() % 10
                + Build.MODEL.length() % 10
                + Build.PRODUCT.length() % 10
                + Build.TAGS.length() % 10
                + Build.TYPE.length() % 10
                + Build.USER.length() % 10;  //13 digits

        return mDeviceID;
    }
}
